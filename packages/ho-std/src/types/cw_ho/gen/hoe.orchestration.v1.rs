// This file is @generated by prost-build.
/// Cosmic Orchestration Types
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct CosmicTask {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "OrchestrateTask", tag = "2")]
    pub task_type: i32,
    #[prost(enumeration = "CosmicTaskStatus", tag = "3")]
    pub status: i32,
    #[prost(string, tag = "4")]
    pub prompt: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub fractal_requirements: ::core::option::Option<FractalRequirements>,
    #[prost(message, optional, tag = "6")]
    pub created_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub updated_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub result: ::core::option::Option<::pbjson_types::Struct>,
    #[prost(string, optional, tag = "9")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for CosmicTask {
    const NAME: &'static str = "CosmicTask";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.CosmicTask".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.CosmicTask".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct CosmicContext {
    #[prost(string, tag = "1")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub user_input: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub current_step: u32,
    #[prost(uint32, tag = "4")]
    pub total_steps: u32,
    #[prost(uint32, tag = "5")]
    pub fractal_level: u32,
    #[prost(string, tag = "6")]
    pub golden_ratio_state: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "7")]
    pub previous_responses: ::prost::alloc::vec::Vec<PromptResponse>,
    #[prost(map = "string, message", tag = "8")]
    pub cosmic_metadata:
        ::std::collections::HashMap<::prost::alloc::string::String, ::pbjson_types::Struct>,
}
impl ::prost::Name for CosmicContext {
    const NAME: &'static str = "CosmicContext";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.CosmicContext".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.CosmicContext".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FractalRequirements {
    #[prost(message, optional, tag = "1")]
    pub context: ::core::option::Option<CosmicContext>,
    #[prost(uint32, tag = "2")]
    pub recursion_depth: u32,
    #[prost(double, tag = "3")]
    pub self_similarity_threshold: f64,
    #[prost(bool, tag = "4")]
    pub golden_ratio_compliance: bool,
    #[prost(double, tag = "5")]
    pub fractal_dimension_target: f64,
    #[prost(bool, tag = "6")]
    pub mobius_continuity: bool,
    #[prost(double, tag = "7")]
    pub fractal_coherence: f64,
    #[prost(string, repeated, tag = "8")]
    pub expansion_criteria: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for FractalRequirements {
    const NAME: &'static str = "FractalRequirements";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.FractalRequirements".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.FractalRequirements".into()
    }
}
/// LLM and Prompt Types
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct PromptRequest {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<PromptMessage>,
    #[prost(string, tag = "2")]
    pub model: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub context: ::core::option::Option<PromptContext>,
    #[prost(message, optional, tag = "4")]
    pub llm_config: ::core::option::Option<LlmPromptConfig>,
}
impl ::prost::Name for PromptRequest {
    const NAME: &'static str = "PromptRequest";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.PromptRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.PromptRequest".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct PromptResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub provider: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub model: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub prompt: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "5")]
    pub response: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub timestamp: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub tokens_used: ::core::option::Option<TokenUsage>,
    #[prost(double, optional, tag = "8")]
    pub cost: ::core::option::Option<f64>,
    #[prost(uint64, optional, tag = "9")]
    pub latency_ms: ::core::option::Option<u64>,
}
impl ::prost::Name for PromptResponse {
    const NAME: &'static str = "PromptResponse";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.PromptResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.PromptResponse".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PromptMessage {
    #[prost(string, tag = "1")]
    pub role: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
}
impl ::prost::Name for PromptMessage {
    const NAME: &'static str = "PromptMessage";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.PromptMessage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.PromptMessage".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PromptContext {
    #[prost(string, optional, tag = "1")]
    pub session_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub user_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub thread_id: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for PromptContext {
    const NAME: &'static str = "PromptContext";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.PromptContext".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.PromptContext".into()
    }
}
#[derive(
    serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message,
)]
pub struct TokenUsage {
    #[prost(uint32, tag = "1")]
    pub prompt: u32,
    #[prost(uint32, tag = "2")]
    pub completion: u32,
    #[prost(uint32, tag = "3")]
    pub total: u32,
}
impl ::prost::Name for TokenUsage {
    const NAME: &'static str = "TokenUsage";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.TokenUsage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.TokenUsage".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LlmPromptConfig {
    #[prost(uint32, tag = "1")]
    pub temperature: u32,
    #[prost(uint32, tag = "2")]
    pub max_tokens: u32,
    #[prost(uint32, tag = "3")]
    pub top_p: u32,
    #[prost(string, repeated, tag = "4")]
    pub stop_sequences: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for LlmPromptConfig {
    const NAME: &'static str = "LlmPromptConfig";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.LlmPromptConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.LlmPromptConfig".into()
    }
}
/// LLM Provider Types
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LlmProvider {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub base_url: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub supported_models: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "LlmModel", tag = "4")]
    pub provider_type: i32,
}
impl ::prost::Name for LlmProvider {
    const NAME: &'static str = "LLMProvider";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.LLMProvider".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.LLMProvider".into()
    }
}
/// Local config structure that matches the existing implementation
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LocalLlmConfig {
    #[prost(uint64, tag = "1")]
    pub timeout_seconds: u64,
    #[prost(string, tag = "2")]
    pub api_keys_file: ::prost::alloc::string::String,
}
impl ::prost::Name for LocalLlmConfig {
    const NAME: &'static str = "LocalLlmConfig";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.LocalLlmConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.LocalLlmConfig".into()
    }
}
/// Configuration Types
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct HoConfig {
    #[prost(message, optional, tag = "1")]
    pub network: ::core::option::Option<super::super::network::v1::NetworkConfig>,
    #[prost(message, optional, tag = "2")]
    pub identity: ::core::option::Option<super::super::network::v1::NodeIdentity>,
    #[prost(message, optional, tag = "3")]
    pub storage: ::core::option::Option<StorageConfig>,
    #[prost(message, optional, tag = "4")]
    pub llm: ::core::option::Option<LlmRouterConfig>,
}
impl ::prost::Name for HoConfig {
    const NAME: &'static str = "HoConfig";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.HoConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.HoConfig".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StorageConfig {
    #[prost(string, tag = "1")]
    pub data_dir: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub max_size_mb: u32,
    #[prost(bool, tag = "3")]
    pub enable_compression: bool,
}
impl ::prost::Name for StorageConfig {
    const NAME: &'static str = "StorageConfig";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.StorageConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.StorageConfig".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct OpenAiRequest {
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub messages: ::prost::alloc::vec::Vec<OpenAiMessage>,
    #[prost(uint32, optional, tag = "3")]
    pub temperature: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub max_tokens: ::core::option::Option<u32>,
}
impl ::prost::Name for OpenAiRequest {
    const NAME: &'static str = "OpenAiRequest";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.OpenAiRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.OpenAiRequest".into()
    }
}
#[derive(
    serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message,
)]
pub struct OpenAiUsage {
    #[prost(uint32, tag = "1")]
    pub prompt_tokens: u32,
    #[prost(uint32, tag = "2")]
    pub completion_tokens: u32,
    #[prost(uint32, tag = "3")]
    pub total_tokens: u32,
}
impl ::prost::Name for OpenAiUsage {
    const NAME: &'static str = "OpenAiUsage";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.OpenAiUsage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.OpenAiUsage".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OpenAiMessage {
    #[prost(string, tag = "1")]
    pub role: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
}
impl ::prost::Name for OpenAiMessage {
    const NAME: &'static str = "OpenAiMessage";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.OpenAiMessage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.OpenAiMessage".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct OpenAiResponse {
    #[prost(message, repeated, tag = "1")]
    pub choices: ::prost::alloc::vec::Vec<OpenAiChoice>,
    #[prost(message, optional, tag = "2")]
    pub usage: ::core::option::Option<OpenAiUsage>,
}
impl ::prost::Name for OpenAiResponse {
    const NAME: &'static str = "OpenAiResponse";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.OpenAiResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.OpenAiResponse".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OpenAiChoice {
    #[prost(message, optional, tag = "1")]
    pub message: ::core::option::Option<OpenAiMessage>,
}
impl ::prost::Name for OpenAiChoice {
    const NAME: &'static str = "OpenAiChoice";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.OpenAiChoice".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.OpenAiChoice".into()
    }
}
/// Llm config is the global configuration of all llm models available, and their subconfigurations.
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct LlmRouterConfig {
    #[prost(string, tag = "1")]
    pub api_keys_file: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub entities: ::prost::alloc::vec::Vec<LlmEntity>,
    #[prost(enumeration = "ModelSelectionStrategy", tag = "3")]
    pub default_strategy: i32,
    #[prost(uint64, tag = "4")]
    pub timeout_seconds: u64,
    #[prost(uint32, tag = "5")]
    pub max_retries: u32,
    #[prost(uint32, tag = "6")]
    pub default_entity: u32,
}
impl ::prost::Name for LlmRouterConfig {
    const NAME: &'static str = "LlmRouterConfig";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.LlmRouterConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.LlmRouterConfig".into()
    }
}
/// / LlmEntity is a single llm model entity. Contains information about available models, stragegy in use of the framework, and other configuration files
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LlmEntity {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub base_url: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub models: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub default_model: ::prost::alloc::string::String,
    /// Using uint32 for u8
    #[prost(uint32, tag = "5")]
    pub priority: u32,
    #[prost(bool, tag = "6")]
    pub enabled: bool,
    #[prost(enumeration = "ModelSelectionStrategy", tag = "7")]
    pub default_strategy: i32,
    #[prost(uint64, tag = "8")]
    pub timeout_seconds: u64,
    #[prost(uint32, tag = "9")]
    pub max_retries: u32,
}
impl ::prost::Name for LlmEntity {
    const NAME: &'static str = "LlmEntity";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.LlmEntity".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.LlmEntity".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LoggingConfig {
    #[prost(string, tag = "1")]
    pub level: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub file: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for LoggingConfig {
    const NAME: &'static str = "LoggingConfig";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.LoggingConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.LoggingConfig".into()
    }
}
/// Health endpoint
#[derive(
    serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message,
)]
pub struct HealthRequest {}
impl ::prost::Name for HealthRequest {
    const NAME: &'static str = "HealthRequest";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.HealthRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.HealthRequest".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HealthResponse {
    #[prost(string, tag = "1")]
    pub status: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub uptime_seconds: u64,
    #[prost(string, tag = "4")]
    pub storage_status: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "5")]
    pub network_status: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for HealthResponse {
    const NAME: &'static str = "HealthResponse";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.HealthResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.HealthResponse".into()
    }
}
/// Query endpoint
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryPromptsRequest {
    #[prost(string, optional, tag = "1")]
    pub session_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub user_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "3")]
    pub limit: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag = "4")]
    pub before_timestamp: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "5")]
    pub after_timestamp: ::core::option::Option<u64>,
}
impl ::prost::Name for QueryPromptsRequest {
    const NAME: &'static str = "QueryPromptsRequest";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.QueryPromptsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.QueryPromptsRequest".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct QueryPromptsResponse {
    #[prost(message, repeated, tag = "1")]
    pub prompts: ::prost::alloc::vec::Vec<PromptResponse>,
    #[prost(uint32, tag = "2")]
    pub total_count: u32,
}
impl ::prost::Name for QueryPromptsResponse {
    const NAME: &'static str = "QueryPromptsResponse";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.QueryPromptsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.QueryPromptsResponse".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BootstrapRequest {
    /// bootstrap method
    #[prost(message, optional, tag = "1")]
    pub bootstrap_method: ::core::option::Option<BootstrapMethod>,
    /// node-identity
    #[prost(message, optional, tag = "2")]
    pub identity: ::core::option::Option<super::super::network::v1::NodeIdentity>,
}
impl ::prost::Name for BootstrapRequest {
    const NAME: &'static str = "BootstrapRequest";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.BootstrapRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.BootstrapRequest".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BootstrapMethod {
    #[prost(oneof = "bootstrap_method::Method", tags = "1, 2, 3, 4")]
    pub method: ::core::option::Option<bootstrap_method::Method>,
}
/// Nested message and enum types in `BootstrapMethod`.
pub mod bootstrap_method {
    #[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Method {
        #[prost(message, tag = "1")]
        Ssh(super::Ssh),
        #[prost(message, tag = "2")]
        Cloud(super::Cloud),
        #[prost(message, tag = "3")]
        Docker(super::Docker),
        #[prost(message, tag = "4")]
        Bluetooth(super::Bluetooth),
    }
}
impl ::prost::Name for BootstrapMethod {
    const NAME: &'static str = "BootstrapMethod";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.BootstrapMethod".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.BootstrapMethod".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Ssh {
    #[prost(string, tag = "1")]
    pub ssh_key_path: ::prost::alloc::string::String,
}
impl ::prost::Name for Ssh {
    const NAME: &'static str = "Ssh";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.Ssh".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.Ssh".into()
    }
}
#[derive(
    serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message,
)]
pub struct Cloud {
    #[prost(oneof = "cloud::Provider", tags = "1, 2, 3")]
    pub provider: ::core::option::Option<cloud::Provider>,
}
/// Nested message and enum types in `Cloud`.
pub mod cloud {
    #[derive(
        serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof,
    )]
    pub enum Provider {
        #[prost(message, tag = "1")]
        Akash(super::Akash),
        #[prost(message, tag = "2")]
        Wavs(super::Wavs),
        #[prost(message, tag = "3")]
        Phala(super::Phala),
    }
}
impl ::prost::Name for Cloud {
    const NAME: &'static str = "Cloud";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.Cloud".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.Cloud".into()
    }
}
#[derive(
    serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message,
)]
pub struct Bluetooth {}
impl ::prost::Name for Bluetooth {
    const NAME: &'static str = "Bluetooth";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.Bluetooth".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.Bluetooth".into()
    }
}
#[derive(
    serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message,
)]
pub struct Local {}
impl ::prost::Name for Local {
    const NAME: &'static str = "Local";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.Local".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.Local".into()
    }
}
#[derive(
    serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message,
)]
pub struct Docker {}
impl ::prost::Name for Docker {
    const NAME: &'static str = "Docker";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.Docker".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.Docker".into()
    }
}
#[derive(
    serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message,
)]
pub struct Akash {}
impl ::prost::Name for Akash {
    const NAME: &'static str = "Akash";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.Akash".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.Akash".into()
    }
}
#[derive(
    serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message,
)]
pub struct Wavs {}
impl ::prost::Name for Wavs {
    const NAME: &'static str = "Wavs";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.Wavs".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.Wavs".into()
    }
}
#[derive(
    serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message,
)]
pub struct Phala {}
impl ::prost::Name for Phala {
    const NAME: &'static str = "Phala";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.Phala".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.Phala".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BootstrapResponse {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub target_node: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub status: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub summary: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub timestamp: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(uint64, tag = "6")]
    pub duration_ms: u64,
}
impl ::prost::Name for BootstrapResponse {
    const NAME: &'static str = "BootstrapResponse";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.BootstrapResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.BootstrapResponse".into()
    }
}
/// Bootstrap endpoint
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BootstrapNodeRequest {
    /// name provided to the node you are bootstrapping
    #[prost(string, tag = "1")]
    pub target_node: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub ssh_key_path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub ssh_user: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub ssh_port: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for BootstrapNodeRequest {
    const NAME: &'static str = "BootstrapNodeRequest";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.BootstrapNodeRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.BootstrapNodeRequest".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BootstrapNodeResponse {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub target_node: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub status: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub summary: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub timestamp: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(uint64, tag = "6")]
    pub duration_ms: u64,
}
impl ::prost::Name for BootstrapNodeResponse {
    const NAME: &'static str = "BootstrapNodeResponse";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.BootstrapNodeResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.BootstrapNodeResponse".into()
    }
}
/// Fractal creation endpoint
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct CreateFractalRequest {
    #[prost(string, tag = "1")]
    pub prompt: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub requirements: ::core::option::Option<FractalRequirements>,
    #[prost(message, optional, tag = "3")]
    pub context: ::core::option::Option<PromptContext>,
}
impl ::prost::Name for CreateFractalRequest {
    const NAME: &'static str = "CreateFractalRequest";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.CreateFractalRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.CreateFractalRequest".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateFractalResponse {
    #[prost(string, tag = "1")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(enumeration = "CosmicTaskStatus", tag = "2")]
    pub status: i32,
    #[prost(string, optional, tag = "3")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub created_at: ::core::option::Option<::pbjson_types::Timestamp>,
}
impl ::prost::Name for CreateFractalResponse {
    const NAME: &'static str = "CreateFractalResponse";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.CreateFractalResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.CreateFractalResponse".into()
    }
}
/// Prune endpoint
#[derive(
    serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message,
)]
pub struct PruneNodeRequest {
    #[prost(bool, tag = "1")]
    pub force: bool,
    #[prost(uint64, optional, tag = "2")]
    pub retain_after_timestamp: ::core::option::Option<u64>,
}
impl ::prost::Name for PruneNodeRequest {
    const NAME: &'static str = "PruneNodeRequest";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.PruneNodeRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.PruneNodeRequest".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PruneNodeResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(uint64, tag = "2")]
    pub pruned_bytes: u64,
    #[prost(uint64, tag = "3")]
    pub pruned_entries: u64,
    #[prost(string, optional, tag = "4")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for PruneNodeResponse {
    const NAME: &'static str = "PruneNodeResponse";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.PruneNodeResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.PruneNodeResponse".into()
    }
}
/// Network topology endpoint
#[derive(
    serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message,
)]
pub struct GetTopologyRequest {}
impl ::prost::Name for GetTopologyRequest {
    const NAME: &'static str = "GetTopologyRequest";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.GetTopologyRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.GetTopologyRequest".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct GetTopologyResponse {
    #[prost(message, optional, tag = "1")]
    pub topology: ::core::option::Option<super::super::network::v1::NetworkTopology>,
    #[prost(message, optional, tag = "2")]
    pub node_identity: ::core::option::Option<super::super::network::v1::NodeIdentity>,
}
impl ::prost::Name for GetTopologyResponse {
    const NAME: &'static str = "GetTopologyResponse";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.GetTopologyResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.GetTopologyResponse".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RouteMetadata {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "HttpMethod", tag = "3")]
    pub method: i32,
    #[prost(bool, tag = "4")]
    pub requires_auth: bool,
    /// Proto type URL (e.g., "hoe.orchestration.v1.HealthRequest")
    #[prost(string, tag = "5")]
    pub request_type: ::prost::alloc::string::String,
    /// Proto type URL (e.g., "hoe.orchestration.v1.HealthResponse")
    #[prost(string, tag = "6")]
    pub response_type: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "7")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for RouteMetadata {
    const NAME: &'static str = "RouteMetadata";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.RouteMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.RouteMetadata".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct RouteRegistry {
    #[prost(message, repeated, tag = "1")]
    pub routes: ::prost::alloc::vec::Vec<RouteMetadata>,
}
impl ::prost::Name for RouteRegistry {
    const NAME: &'static str = "RouteRegistry";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.RouteRegistry".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.RouteRegistry".into()
    }
}
/// JSON structure for the api-keys.json file
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct ApiKeysJson {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<ApiKeysMetadata>,
    #[prost(map = "string, message", tag = "2")]
    pub providers: ::std::collections::HashMap<::prost::alloc::string::String, ProviderWithAuth>,
    #[prost(message, optional, tag = "3")]
    pub global_settings: ::core::option::Option<GlobalSettings>,
    #[prost(message, optional, tag = "4")]
    pub instructions: ::core::option::Option<Instructions>,
}
impl ::prost::Name for ApiKeysJson {
    const NAME: &'static str = "ApiKeysJson";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.ApiKeysJson".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.ApiKeysJson".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ApiKeysMetadata {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3")]
    pub golden_ratio_note: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for ApiKeysMetadata {
    const NAME: &'static str = "ApiKeysMetadata";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.ApiKeysMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.ApiKeysMetadata".into()
    }
}
/// / Provider configuration with authentication
/// / Combines LlmEntity (standard type) with api_key and prompt defaults
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProviderWithAuth {
    #[prost(string, optional, tag = "1")]
    pub api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub entity: ::core::option::Option<LlmEntity>,
}
impl ::prost::Name for ProviderWithAuth {
    const NAME: &'static str = "ProviderWithAuth";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.ProviderWithAuth".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.ProviderWithAuth".into()
    }
}
#[derive(
    serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message,
)]
pub struct GlobalSettings {
    #[prost(int32, tag = "1")]
    pub default_timeout_seconds: i32,
    #[prost(int32, tag = "2")]
    pub max_retry_attempts: i32,
    #[prost(bool, tag = "3")]
    pub golden_ratio_weighting: bool,
    #[prost(bool, tag = "4")]
    pub fallback_enabled: bool,
    #[prost(int32, tag = "5")]
    pub health_check_interval_seconds: i32,
}
impl ::prost::Name for GlobalSettings {
    const NAME: &'static str = "GlobalSettings";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.GlobalSettings".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.GlobalSettings".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Instructions {
    #[prost(string, repeated, tag = "1")]
    pub setup: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub security: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for Instructions {
    const NAME: &'static str = "Instructions";
    const PACKAGE: &'static str = "hoe.orchestration.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.orchestration.v1.Instructions".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.orchestration.v1.Instructions".into()
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum OrchestrateTask {
    Unspecified = 0,
    Bootstrap = 1,
    Recursive = 2,
}
impl OrchestrateTask {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ORCHESTRATE_TASK_UNSPECIFIED",
            Self::Bootstrap => "ORCHESTRATE_TASK_BOOTSTRAP",
            Self::Recursive => "ORCHESTRATE_TASK_RECURSIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ORCHESTRATE_TASK_UNSPECIFIED" => Some(Self::Unspecified),
            "ORCHESTRATE_TASK_BOOTSTRAP" => Some(Self::Bootstrap),
            "ORCHESTRATE_TASK_RECURSIVE" => Some(Self::Recursive),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum CosmicTaskStatus {
    Unspecified = 0,
    Pending = 1,
    Running = 2,
    Completed = 3,
    Failed = 4,
    FractalExpansion = 5,
    GeometricValidation = 6,
}
impl CosmicTaskStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "COSMIC_TASK_STATUS_UNSPECIFIED",
            Self::Pending => "COSMIC_TASK_STATUS_PENDING",
            Self::Running => "COSMIC_TASK_STATUS_RUNNING",
            Self::Completed => "COSMIC_TASK_STATUS_COMPLETED",
            Self::Failed => "COSMIC_TASK_STATUS_FAILED",
            Self::FractalExpansion => "COSMIC_TASK_STATUS_FRACTAL_EXPANSION",
            Self::GeometricValidation => "COSMIC_TASK_STATUS_GEOMETRIC_VALIDATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COSMIC_TASK_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "COSMIC_TASK_STATUS_PENDING" => Some(Self::Pending),
            "COSMIC_TASK_STATUS_RUNNING" => Some(Self::Running),
            "COSMIC_TASK_STATUS_COMPLETED" => Some(Self::Completed),
            "COSMIC_TASK_STATUS_FAILED" => Some(Self::Failed),
            "COSMIC_TASK_STATUS_FRACTAL_EXPANSION" => Some(Self::FractalExpansion),
            "COSMIC_TASK_STATUS_GEOMETRIC_VALIDATION" => Some(Self::GeometricValidation),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum LlmModel {
    AkashChat = 0,
    OllamaLocal = 1,
    KimiResearch = 2,
    Grok = 3,
    OpenAi = 4,
    Anthropic = 5,
    Custom = 6,
}
impl LlmModel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AkashChat => "AkashChat",
            Self::OllamaLocal => "OllamaLocal",
            Self::KimiResearch => "KimiResearch",
            Self::Grok => "Grok",
            Self::OpenAi => "OpenAI",
            Self::Anthropic => "Anthropic",
            Self::Custom => "Custom",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AkashChat" => Some(Self::AkashChat),
            "OllamaLocal" => Some(Self::OllamaLocal),
            "KimiResearch" => Some(Self::KimiResearch),
            "Grok" => Some(Self::Grok),
            "OpenAI" => Some(Self::OpenAi),
            "Anthropic" => Some(Self::Anthropic),
            "Custom" => Some(Self::Custom),
            _ => None,
        }
    }
}
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ModelSelectionStrategy {
    Unspecified = 0,
    /// Always use highest priority available
    Priority = 1,
    /// Round-robin across available providers
    RoundRobin = 2,
    /// Golden ratio weighted selection
    GoldenRatio = 3,
    /// Load-based selection
    LoadBalanced = 4,
}
impl ModelSelectionStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MODEL_SELECTION_STRATEGY_UNSPECIFIED",
            Self::Priority => "MODEL_SELECTION_STRATEGY_PRIORITY",
            Self::RoundRobin => "MODEL_SELECTION_STRATEGY_ROUND_ROBIN",
            Self::GoldenRatio => "MODEL_SELECTION_STRATEGY_GOLDEN_RATIO",
            Self::LoadBalanced => "MODEL_SELECTION_STRATEGY_LOAD_BALANCED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MODEL_SELECTION_STRATEGY_UNSPECIFIED" => Some(Self::Unspecified),
            "MODEL_SELECTION_STRATEGY_PRIORITY" => Some(Self::Priority),
            "MODEL_SELECTION_STRATEGY_ROUND_ROBIN" => Some(Self::RoundRobin),
            "MODEL_SELECTION_STRATEGY_GOLDEN_RATIO" => Some(Self::GoldenRatio),
            "MODEL_SELECTION_STRATEGY_LOAD_BALANCED" => Some(Self::LoadBalanced),
            _ => None,
        }
    }
}
/// Route Metadata and Configuration
#[derive(
    serde::Serialize,
    serde::Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum HttpMethod {
    Unspecified = 0,
    Get = 1,
    Post = 2,
    Put = 3,
    Delete = 4,
    Patch = 5,
}
impl HttpMethod {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "HTTP_METHOD_UNSPECIFIED",
            Self::Get => "HTTP_METHOD_GET",
            Self::Post => "HTTP_METHOD_POST",
            Self::Put => "HTTP_METHOD_PUT",
            Self::Delete => "HTTP_METHOD_DELETE",
            Self::Patch => "HTTP_METHOD_PATCH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HTTP_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
            "HTTP_METHOD_GET" => Some(Self::Get),
            "HTTP_METHOD_POST" => Some(Self::Post),
            "HTTP_METHOD_PUT" => Some(Self::Put),
            "HTTP_METHOD_DELETE" => Some(Self::Delete),
            "HTTP_METHOD_PATCH" => Some(Self::Patch),
            _ => None,
        }
    }
}
