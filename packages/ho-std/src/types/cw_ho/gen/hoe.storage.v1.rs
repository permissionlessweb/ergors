// This file is @generated by prost-build.
/// Storage-specific types
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct StorageQuery {
    #[prost(string, optional, tag = "1")]
    pub session_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub user_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub end_time: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(uint32, optional, tag = "5")]
    pub limit: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub offset: ::core::option::Option<u32>,
    #[prost(map = "string, string", tag = "7")]
    pub filters:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
impl ::prost::Name for StorageQuery {
    const NAME: &'static str = "StorageQuery";
    const PACKAGE: &'static str = "hoe.storage.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.storage.v1.StorageQuery".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.storage.v1.StorageQuery".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StorageIndex {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub created_at: ::core::option::Option<::pbjson_types::Timestamp>,
}
impl ::prost::Name for StorageIndex {
    const NAME: &'static str = "StorageIndex";
    const PACKAGE: &'static str = "hoe.storage.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.storage.v1.StorageIndex".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.storage.v1.StorageIndex".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct StorageSnapshot {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub created_at: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(string, tag = "3")]
    pub state_root: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub version: u64,
    #[prost(map = "string, bytes", tag = "5")]
    pub data:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::vec::Vec<u8>>,
}
impl ::prost::Name for StorageSnapshot {
    const NAME: &'static str = "StorageSnapshot";
    const PACKAGE: &'static str = "hoe.storage.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.storage.v1.StorageSnapshot".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.storage.v1.StorageSnapshot".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct StorageMetrics {
    #[prost(uint64, tag = "1")]
    pub total_entries: u64,
    #[prost(uint64, tag = "2")]
    pub storage_size_bytes: u64,
    #[prost(uint64, tag = "3")]
    pub index_size_bytes: u64,
    #[prost(message, optional, tag = "4")]
    pub last_compaction: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(double, tag = "5")]
    pub fragmentation_ratio: f64,
}
impl ::prost::Name for StorageMetrics {
    const NAME: &'static str = "StorageMetrics";
    const PACKAGE: &'static str = "hoe.storage.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.storage.v1.StorageMetrics".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.storage.v1.StorageMetrics".into()
    }
}
/// Keep existing API types for backward compatibility
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryRequest {
    #[prost(string, optional, tag = "1")]
    pub session_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub user_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub end_time: ::core::option::Option<::pbjson_types::Timestamp>,
    #[prost(uint32, optional, tag = "5")]
    pub limit: ::core::option::Option<u32>,
}
impl ::prost::Name for QueryRequest {
    const NAME: &'static str = "QueryRequest";
    const PACKAGE: &'static str = "hoe.storage.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.storage.v1.QueryRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.storage.v1.QueryRequest".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HealthResponse {
    #[prost(string, tag = "1")]
    pub status: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub uptime_seconds: u64,
    #[prost(string, tag = "4")]
    pub storage_status: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "5")]
    pub network_status: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for HealthResponse {
    const NAME: &'static str = "HealthResponse";
    const PACKAGE: &'static str = "hoe.storage.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.storage.v1.HealthResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.storage.v1.HealthResponse".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ErrorResponse {
    #[prost(string, tag = "1")]
    pub error: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub code: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::core::option::Option<::pbjson_types::Timestamp>,
}
impl ::prost::Name for ErrorResponse {
    const NAME: &'static str = "ErrorResponse";
    const PACKAGE: &'static str = "hoe.storage.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.storage.v1.ErrorResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.storage.v1.ErrorResponse".into()
    }
}
