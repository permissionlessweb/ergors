// This file is @generated by prost-build.
/// Represents the CLI command to execute
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HoCommand {
    #[prost(oneof = "ho_command::Command", tags = "1, 2, 3")]
    pub command: ::core::option::Option<ho_command::Command>,
}
/// Nested message and enum types in `HoCommand`.
pub mod ho_command {
    #[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Command {
        #[prost(message, tag = "1")]
        Start(super::StartHo),
        #[prost(message, tag = "2")]
        Init(super::InitHo),
        #[prost(message, tag = "3")]
        Health(super::HealthHo),
    }
}
impl ::prost::Name for HoCommand {
    const NAME: &'static str = "HoCommand";
    const PACKAGE: &'static str = "hoe.types.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.types.v1.HoCommand".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.types.v1.HoCommand".into()
    }
}
#[derive(
    serde::Serialize, serde::Deserialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message,
)]
pub struct StartHo {
    #[prost(uint32, optional, tag = "1")]
    pub port: ::core::option::Option<u32>,
}
impl ::prost::Name for StartHo {
    const NAME: &'static str = "StartHo";
    const PACKAGE: &'static str = "hoe.types.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.types.v1.StartHo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.types.v1.StartHo".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InitHo {
    #[prost(string, tag = "1")]
    pub output: ::prost::alloc::string::String,
}
impl ::prost::Name for InitHo {
    const NAME: &'static str = "InitHo";
    const PACKAGE: &'static str = "hoe.types.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.types.v1.InitHo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.types.v1.InitHo".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HealthHo {
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
}
impl ::prost::Name for HealthHo {
    const NAME: &'static str = "HealthHo";
    const PACKAGE: &'static str = "hoe.types.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.types.v1.HealthHo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.types.v1.HealthHo".into()
    }
}
/// Basic operation types for state management
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct InsertOperation {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<::pbjson_types::Struct>,
}
impl ::prost::Name for InsertOperation {
    const NAME: &'static str = "InsertOperation";
    const PACKAGE: &'static str = "hoe.types.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.types.v1.InsertOperation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.types.v1.InsertOperation".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct UpdateOperation {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<::pbjson_types::Struct>,
}
impl ::prost::Name for UpdateOperation {
    const NAME: &'static str = "UpdateOperation";
    const PACKAGE: &'static str = "hoe.types.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.types.v1.UpdateOperation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.types.v1.UpdateOperation".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteOperation {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteOperation {
    const NAME: &'static str = "DeleteOperation";
    const PACKAGE: &'static str = "hoe.types.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.types.v1.DeleteOperation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.types.v1.DeleteOperation".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Message)]
pub struct FractalOperation {
    #[prost(oneof = "fractal_operation::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<fractal_operation::Operation>,
}
/// Nested message and enum types in `FractalOperation`.
pub mod fractal_operation {
    #[derive(serde::Serialize, serde::Deserialize, Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        #[prost(message, tag = "1")]
        Insert(super::InsertOperation),
        #[prost(message, tag = "2")]
        Update(super::UpdateOperation),
        #[prost(message, tag = "3")]
        Delete(super::DeleteOperation),
    }
}
impl ::prost::Name for FractalOperation {
    const NAME: &'static str = "FractalOperation";
    const PACKAGE: &'static str = "hoe.types.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "hoe.types.v1.FractalOperation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/hoe.types.v1.FractalOperation".into()
    }
}
